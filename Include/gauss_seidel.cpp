#ifndef __gaussseidel__
	#define __gaussseidel__
	#include "FixedPointTraits.hpp"
	#include "Accelerators.hpp"
	namespace FixedPoint
	{
		
		//! @brief Implements an iteration of Gauss-Seidel iterative scheme
		//!
		//! Generalizes for my purposes the simple iterations in the HeatExchange
		//! directory in the PACS repository of Luca Formaggia.
		//! Solves a linear system generated by a tridiagonal matrix of this type:
		//! (A + I x.^3) z = rhs
		//! where A is the FEM matrix (2+h^2*a on the diagonal except last number that is one,
		//! -1 on upper and lower diagonals), I is the identity matrix, x.^3 is the vector whose
		//! components are the cube of those of x, that is the previous iterate of a nonlinear
		//! iterative solver.
		class GaussSeidelIterator: public Traits 
		{
			public:
			//! @brief constructor
			//!
			//! @param size   Number of elements (also of unknowns)
			//! @param s		Thermal radiation coefficient
			//! @param v		The vector x of previous description (previous iteration of
			//! the nonlinear solver)
			GaussSeidelIterator(const int size, const Vector & v, const double s): 
			M(size), x(v), sigma(s), diagonal ( 2*Vector::Ones(size).array()+
			h*h*( act*Vector::Ones(size).array() + sigma*x.array()*x.array()*x.array())),
			rhs ( Vector::Zero ( size ) )
			{
				// This is the Dirichlet condition of my problem
				rhs[0] = (To-Te)/Te;
			};
			
			//! call operator: is the update formula of Gauss-Seidel
			Vector operator ()(const Vector & z) const
			{
				Vector y(M);
				y[0] = ( rhs[0] + z[1] ) / diagonal[0];
				for(int m=1; m < M-1; ++m)
				{  
					y[m]  = ( rhs[m] + y[m-1] + z[m+1]) / diagonal[m];
				}      
				y[M-1] =  rhs[M-1] + y[M-2];
				return y;
			}
			// A few problem data
			static constexpr double L= 40.;  // Bar length
			static constexpr double a1=4.; // First longitudinal dimension
			static constexpr double a2=50; //  Second longitudinal dimension
			static constexpr double To=46.; // Dirichlet condition
			static constexpr double Te=20.; // External temperature (Centigrades)
			static constexpr double k=0.164;  // Thermal conductivity
			static constexpr double hc=200.0e-6; // Convection coefficient
			// Precomputed coefficient for adimensional form of equation
			static constexpr double act=2.*(a1+a2)*hc*L*L/(k*a1*a2);
			
			//! Thermal radiation coefficient
			double sigma; 
			//! Number of grid elements
			const int M;
			//! Previous nonlinear iterate
			const Vector & x;
			
			//! mesh size
			const double h=1./M;
			//! The diagonal of the linear system
			Vector diagonal;
			//! Right-hand side
			Vector rhs;
			
			//! Residual evaluation (the f(x_k) of Newton method)
			Vector f () const{
				Vector y(M);
				y[0]= diagonal[0]*x[0]-x[1]-rhs[0];
				for(int m=1; m < M-1; ++m){
					y[m]= diagonal[m]*x[m] - x[m-1] - x[m+1] - rhs[m];
				}
				y[M-1] = x[M-1]-x[M-2]-rhs[M-1];
				return y;
			}
			
		};
	}
	
#endif